<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Module System to Control Scope and Privacy - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title-page.html">The Rust Programming Language</a></li><li class="affix"><a href="foreword.html">Foreword</a></li><li class="affix"><a href="ch00-00-introduction.html">Introduction</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Packages, Crates, and Modules</a></li><li><ol class="section"><li><a href="ch07-01-packages-and-crates-for-making-libraries-and-executables.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates for Making Libraries and Executables</a></li><li><a href="ch07-02-modules-and-use-to-control-scope-and-privacy.html" class="active"><strong aria-hidden="true">7.2.</strong> The Module System to Control Scope and Privacy</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box<T> to Point to Data on the Heap</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions and Closures</a></li><li><a href="ch19-06-macros.html"><strong aria-hidden="true">19.6.</strong> Macros</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#the-module-system-to-control-scope-and-privacy" id="the-module-system-to-control-scope-and-privacy"><h2>The Module System to Control Scope and Privacy</h2></a>
<p>Rust has a feature that’s often referred to as “the module system,” but it
encompasses a few more features than modules. In this section, we’ll talk about:</p>
<ul>
<li>Modules, a way to organize code and control the privacy of paths</li>
<li>Paths, a way to name items</li>
<li><code>use</code>, a keyword to bring a path into scope</li>
<li><code>pub</code>, a keyword to make items public</li>
<li>Renaming items when bringing them into scope with the <code>as</code> keyword</li>
<li>Using external packages</li>
<li>Nested paths to clean up large <code>use</code> lists</li>
<li>Using the glob operator to bring everything in a module into scope</li>
<li>How to split modules into individual files</li>
</ul>
<p>First up, modules. Modules let us organize code into groups. Listing 7-1 has an
example of some code that defines a module named <code>sound</code> that contains a
function named <code>guitar</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    fn guitar() {
        // Function body code goes here
    }
}

fn main() {

}
</code></pre></pre>
<p><span class="caption">Listing 7-1: A <code>sound</code> module containing a <code>guitar</code>
function and a <code>main</code> function</span></p>
<p>We’ve defined two functions, <code>guitar</code> and <code>main</code>. We’ve defined the <code>guitar</code>
function within a <code>mod</code> block. This block defines a module named <code>sound</code>.</p>
<p>To organize code into a hierarchy of modules, you can nest modules inside of
other modules, as shown in Listing 7-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    mod instrument {
        mod woodwind {
            fn clarinet() {
                // Function body code goes here
            }
        }
    }

    mod voice {

    }
}

fn main() {

}
</code></pre></pre>
<p><span class="caption">Listing 7-2: Modules inside modules</span></p>
<p>In this example, we defined a <code>sound</code> module in the same way as we did in
Listing 7-1. We then defined two modules within the <code>sound</code> module named
<code>instrument</code> and <code>voice</code>. The <code>instrument</code> module has another module defined
within it, <code>woodwind</code>, and that module contains a function named <code>clarinet</code>.</p>
<p>We mentioned in the <a href="ch07-01-packages-and-crates-for-making-libraries-and-executables.html#packages-and-crates-for-making-libraries-and-executables">“Packages and Crates for Making Libraries and
Executables”</a><!-- ignore --> section that <em>src/main.rs</em> and
<em>src/lib.rs</em> are called <em>crate roots</em>. They are called crate roots because the
contents of either of these two files form a module named <code>crate</code> at the root
of the crate’s module tree. So in Listing 7-2, we have a module tree that looks
like Listing 7-3:</p>
<pre><code class="language-text">crate
└── sound
    ├── instrument
    │   └── woodwind
    └── voice
</code></pre>
<p><span class="caption">Listing 7-3: The module tree for the code in Listing
7-2</span></p>
<p>This tree shows how some of the modules nest inside one another (such as
<code>woodwind</code> nests inside <code>instrument</code>) and how some modules are siblings to
each other (<code>instrument</code> and <code>voice</code> are both defined within <code>sound</code>). The
entire module tree is rooted under the implicit module named <code>crate</code>.</p>
<p>This tree might remind you of the directory tree of the filesystem you have on
your computer; this is a very apt comparison! Just like directories in a
filesystem, you place code inside whichever module will create the organization
you’d like. Another similarity is that to refer to an item in a filesystem or a
module tree, you use its <em>path</em>.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#paths-for-referring-to-an-item-in-the-module-tree" id="paths-for-referring-to-an-item-in-the-module-tree"><h3>Paths for Referring to an Item in the Module Tree</h3></a>
<p>If we want to call a function, we need to know its <em>path</em>. “Path” is a synonym
for “name” in a way, but it evokes that filesystem metaphor. Additionally,
functions, structs, and other items may have multiple paths that refer to the
same item, so “name” isn’t quite the right concept.</p>
<p>A <em>path</em> can take two forms:</p>
<ul>
<li>An <em>absolute path</em> starts from a crate root by using a crate name or a
literal <code>crate</code>.</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or
an identifier in the current module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
<p>How do we call the <code>clarinet</code> function in the <code>main</code> function in Listing 7-2?
That is, what’s the path of the <code>clarinet</code> function? In Listing 7-4, let’s
simplify our code a bit by removing some of the modules, and we’ll show two
ways to call the <code>clarinet</code> function from <code>main</code>. This example won’t compile
just yet, we’ll explain why in a bit.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod sound {
    mod instrument {
        fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">Listing 7-4: Calling the <code>clarinet</code> function in a
simplified module tree from the <code>main</code> function using absolute and relative
paths</span></p>
<p>The first way we’re calling the <code>clarinet</code> function from the <code>main</code> function
uses an absolute path. Because <code>clarinet</code> is defined within the same crate as
<code>main</code>, we use the <code>crate</code> keyword to start an absolute path. Then we include
each of the modules until we make our way to <code>clarinet</code>. This is similar to
specifying the path <code>/sound/instrument/clarinet</code> to run the program at that
location on your computer; using the <code>crate</code> name to start from the crate root
is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>The second way we’re calling the <code>clarinet</code> function from the <code>main</code> function
uses a relative path. The path starts with the name <code>sound</code>, a module defined
at the same level of the module tree as the <code>main</code> function. This is similar to
specifying the path <code>sound/instrument/clarinet</code> to run the program at that
location on your computer; starting with a name means that the path is relative.</p>
<p>We mentioned that Listing 7-4 won’t compile yet, let’s try to compile it and
find out why not! The error we get is shown in Listing 7-5.</p>
<pre><code class="language-text">$ cargo build
   Compiling sampleproject v0.1.0 (file:///projects/sampleproject)
error[E0603]: module `instrument` is private
  --&gt; src/main.rs:11:19
   |
11 |     crate::sound::instrument::clarinet();
   |                   ^^^^^^^^^^

error[E0603]: module `instrument` is private
  --&gt; src/main.rs:14:12
   |
14 |     sound::instrument::clarinet();
   |            ^^^^^^^^^^
</code></pre>
<p><span class="caption">Listing 7-5: Compiler errors from building the code in
Listing 7-4</span></p>
<p>The error messages say that module <code>instrument</code> is private. We can see that we
have the correct paths for the <code>instrument</code> module and the <code>clarinet</code> function,
but Rust won’t let us use them because they’re private. It’s time to learn
about the <code>pub</code> keyword!</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#modules-as-the-privacy-boundary" id="modules-as-the-privacy-boundary"><h3>Modules as the Privacy Boundary</h3></a>
<p>Earlier, we talked about the syntax of modules and that they can be used for
organization. There’s another reason Rust has modules: modules are the <em>privacy
boundary</em> in Rust. If you want to make an item like a function or struct
private, you put it in a module. Here are the privacy rules:</p>
<ul>
<li>All items (functions, methods, structs, enums, modules, and constants) are
private by default.</li>
<li>You can use the <code>pub</code> keyword to make an item public.</li>
<li>You aren’t allowed to use private code defined in modules that are children
of the current module.</li>
<li>You are allowed to use any code defined in ancestor modules or the current
module.</li>
</ul>
<p>In other words, items without the <code>pub</code> keyword are private as you look “down”
the module tree from the current module, but items without the <code>pub</code> keyword
are public as you look “up” the tree from the current module. Again, think of a
filesystem: if you don’t have permissions to a directory, you can’t look into
it from its parent directory. If you do have permissions to a directory, you
can look inside it and any of its ancestor directories.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#using-the-pub-keyword-to-make-items-public" id="using-the-pub-keyword-to-make-items-public"><h3>Using the <code>pub</code> Keyword to Make Items Public</h3></a>
<p>The error in Listing 7-5 said the <code>instrument</code> module is private. Let’s mark
the <code>instrument</code> module with the <code>pub</code> keyword so that we can use it from the
<code>main</code> function. This change is shown in Listing 7-6, which still won’t
compile, but we’ll get a different error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod sound {
    pub mod instrument {
        fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">Listing 7-6: Declaring the <code>instrument</code> module as <code>pub</code>
so that we’re allowed to use it from <code>main</code></span></p>
<p>Adding the <code>pub</code> keyword in front of <code>mod instrument</code> makes the module public.
With this change, if we’re allowed to access <code>sound</code>, we can access
<code>instrument</code>. The contents of <code>instrument</code> are still private; making the module
public does not make its contents public. The <code>pub</code> keyword on a module lets
code in its parent module refer to it.</p>
<p>The code in Listing 7-6 still results in an error, though, as shown in Listing
7-7:</p>
<pre><code class="language-text">$ cargo build
   Compiling sampleproject v0.1.0 (file:///projects/sampleproject)
error[E0603]: function `clarinet` is private
  --&gt; src/main.rs:11:31
   |
11 |     crate::sound::instrument::clarinet();
   |                               ^^^^^^^^

error[E0603]: function `clarinet` is private
  --&gt; src/main.rs:14:24
   |
14 |     sound::instrument::clarinet();
   |                        ^^^^^^^^
</code></pre>
<p><span class="caption">Listing 7-7: Compiler errors from building the code in
Listing 7-6</span></p>
<p>The errors now say that the <code>clarinet</code> function is private. The privacy rules
apply to structs, enums, functions, and methods as well as modules.</p>
<p>Let’s make the <code>clarinet</code> function public as well by adding the <code>pub</code> keyword
before its definition, as shown in Listing 7-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">Listing 7-8: Adding the <code>pub</code> keyword to both <code>mod instrument</code> and <code>fn clarinet</code> lets us call the function from <code>main</code></span></p>
<p>This will now compile! Let’s look at both the absolute and the relative path
and double check why adding the <code>pub</code> keyword lets us use these paths in <code>main</code>.</p>
<p>In the absolute path case, we start with <code>crate</code>, the root of our crate. From
there, we have <code>sound</code>, and it is a module that is defined in the crate root.
The <code>sound</code> module isn’t public, but because the <code>main</code> function is defined in
the same module that <code>sound</code> is defined, we’re allowed to refer to <code>sound</code> from
<code>main</code>. Next is <code>instrument</code>, which is a module marked with <code>pub</code>. We can
access the parent module of <code>instrument</code>, so we’re allowed to access
<code>instrument</code>. Finally, <code>clarinet</code> is a function marked with <code>pub</code> and we can
access its parent module, so this function call works!</p>
<p>In the relative path case, the logic is the same as the absolute path except
for the first step. Rather than starting from the crate root, the path starts
from <code>sound</code>. The <code>sound</code> module is defined within the same module as <code>main</code>
is, so the relative path starting from the module in which <code>main</code> is defined
works. Then because <code>instrument</code> and <code>clarinet</code> are marked with <code>pub</code>, the rest
of the path works and this function call is valid as well!</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#starting-relative-paths-with-super" id="starting-relative-paths-with-super"><h3>Starting Relative Paths with <code>super</code></h3></a>
<p>You can also construct relative paths beginning with <code>super</code>. Doing so is like
starting a filesystem path with <code>..</code>: the path starts from the <em>parent</em> module,
rather than the current module. This is useful in situations such as the
example in Listing 7-9, where the function <code>clarinet</code> calls the function
<code>breathe_in</code> by specifying its path to start with <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#
mod instrument {
    fn clarinet() {
        super::breathe_in();
    }
}

fn breathe_in() {
    // Function body code goes here
}
</code></pre></pre>
<p><span class="caption">Listing 7-9: Calling a function using a relative path
starting with <code>super</code> to look in the parent module</span></p>
<p>The <code>clarinet</code> function is in the <code>instrument</code> module, so we can use <code>super</code> to
go to the parent module of <code>instrument</code>, which in this case is <code>crate</code>, the
root. From there, we look for <code>breathe_in</code>, and find it. Success!</p>
<p>The reason you might want to choose a relative path starting with <code>super</code>
rather than an absolute path starting with <code>crate</code> is that using <code>super</code> may
make it easier to update your code to have a different module hierarchy, if the
code defining the item and the code calling the item are moved together. For
example, if we decide to put the <code>instrument</code> module and the <code>breathe_in</code>
function into a module named <code>sound</code>, we would only need to add the <code>sound</code>
module, as shown in Listing 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod sound {
    mod instrument {
        fn clarinet() {
            super::breathe_in();
        }
    }

    fn breathe_in() {
        // Function body code goes here
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-10: Adding a parent module named <code>sound</code>
doesn’t affect the relative path <code>super::breathe_in</code></span></p>
<p>The call to <code>super::breathe_in</code> from the <code>clarinet</code> function will continue to
work in Listing 7-10 as it did in Listing 7-9, without needing to update the
path. If instead of <code>super::breathe_in</code> we had used <code>crate::breathe_in</code> in the
<code>clarinet</code> function, when we add the parent <code>sound</code> module, we would need to
update the <code>clarinet</code> function to use the path <code>crate::sound::breathe_in</code>
instead. Using a relative path can mean fewer updates are necessary when
rearranging modules.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#using-pub-with-structs-and-enums" id="using-pub-with-structs-and-enums"><h3>Using <code>pub</code> with Structs and Enums</h3></a>
<p>You can designate structs and enums to be public in a similar way as we’ve
shown with modules and functions, with a few additional details.</p>
<p>If you use <code>pub</code> before a struct definition, you make the struct public.
However, the struct’s fields are still private. You can choose to make each
field public or not on a case-by-case basis. In Listing 7-11, we’ve defined a
public <code>plant::Vegetable</code> struct with a public <code>name</code> field but a private <code>id</code>
field.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod plant {
    pub struct Vegetable {
        pub name: String,
        id: i32,
    }

    impl Vegetable {
        pub fn new(name: &amp;str) -&gt; Vegetable {
            Vegetable {
                name: String::from(name),
                id: 1,
            }
        }
    }
}

fn main() {
    let mut v = plant::Vegetable::new(&quot;squash&quot;);

    v.name = String::from(&quot;butternut squash&quot;);
    println!(&quot;{} are delicious&quot;, v.name);

    // The next line won't compile if we uncomment it:
    // println!(&quot;The ID is {}&quot;, v.id);
}
</code></pre></pre>
<p><span class="caption">Listing 7-11: A struct with some public fields and some
private fields</span></p>
<p>Because the <code>name</code> field of the <code>plant::Vegetable</code> struct is public, in <code>main</code>
we can write and read to the <code>name</code> field by using dot notation. We’re not
allowed to use the <code>id</code> field in <code>main</code> because it’s private. Try uncommenting
the line printing the <code>id</code> field value to see what error you get! Also note
that because <code>plant::Vegetable</code> has a private field, the struct needs to
provide a public associated function that constructs an instance of <code>Vegetable</code>
(we’ve used the conventional name <code>new</code> here). If <code>Vegetable</code> didn’t have such
a function, we wouldn’t be able to create an instance of <code>Vegetable</code> in <code>main</code>
because we’re not allowed to set the value of the private <code>id</code> field in <code>main</code>.</p>
<p>In contrast, if you make a public enum, all of its variants are public. You
only need the <code>pub</code> before the <code>enum</code> keyword, as shown in Listing 7-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod menu {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

fn main() {
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;
}
</code></pre></pre>
<p><span class="caption">Listing 7-12: Designating an enum as public makes all its
variants public</span></p>
<p>Because we made the <code>Appetizer</code> enum public, we’re able to use the <code>Soup</code> and
<code>Salad</code> variants in <code>main</code>.</p>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that’s
with our last module system feature: the <code>use</code> keyword. Let’s cover <code>use</code> by
itself, and then we’ll show how <code>pub</code> and <code>use</code> can be combined.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#the-use-keyword-to-bring-paths-into-a-scope" id="the-use-keyword-to-bring-paths-into-a-scope"><h3>The <code>use</code> Keyword to Bring Paths into a Scope</h3></a>
<p>You may have been thinking that many of the paths we’ve written to call
functions in the listings in this chapter are long and repetitive. For example,
in Listing 7-8, whether we chose the absolute or relative path to the
<code>clarinet</code> function, every time we wanted to call <code>clarinet</code> we had to specify
<code>sound</code> and <code>instrument</code> too. Luckily, there’s a way to bring a path into a
scope once and then call the items in that path as if they’re local items: with
the <code>use</code> keyword. In Listing 7-13, we bring the <code>crate::sound::instrument</code>
module into the scope of the <code>main</code> function so that we only have to specify
<code>instrument::clarinet</code> to call the <code>clarinet</code> function in <code>main</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use crate::sound::instrument;

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">Listing 7-13: Bringing a module into scope with <code>use</code> and
an absolute path to shorten the path we have to specify to call an item within
that module</span></p>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding <code>use crate::sound::instrument</code> in the crate root,
<code>instrument</code> is now a valid name in that scope as if the <code>instrument</code> module
had been defined in the crate root. We can now reach items in the <code>instrument</code>
module through the older, full paths, or we can reach items through the new,
shorter path that we’ve created with <code>use</code>. Paths brought into scope with <code>use</code>
also check privacy, like any other paths.</p>
<p>If you want to bring an item into scope with <code>use</code> and a relative path, there’s
a small difference from directly calling the item using a relative path:
instead of starting from a name in the current scope, you must start the path
given to <code>use</code> with <code>self</code>. Listing 7-14 shows how to specify a relative path
to get the same behavior as Listing 7-13 that used an absolute path.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use self::sound::instrument;

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">Listing 7-14: Bringing a module into scope with <code>use</code> and
a relative path starting with <code>self</code></span></p>
<p>Starting relative paths with <code>self</code> when specified after <code>use</code> might not be
necessary in the future; it’s an inconsistency in the language that people are
working on eliminating.</p>
<p>Choosing to specify absolute paths with <code>use</code> can make updates easier if the
code calling the items moves to a different place in the module tree but the
code defining the items does not, as opposed to when they moved together in the
changes we made in Listing 7-10. For example, if we decide to take the code
from Listing 7-13, extract the behavior in the <code>main</code> function to a function
called <code>clarinet_trio</code>, and move that function into a module named
<code>performance_group</code>, the path specified in <code>use</code> wouldn’t need to change, as
shown in Listing 7-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

mod performance_group {
    use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
}
</code></pre></pre>
<p><span class="caption">Listing 7-15: The absolute path doesn’t need to be
updated when moving the code that calls the item</span></p>
<p>In contrast, if we made the same change to the code in Listing 7-14 that
specifies a relative path, we would need to change <code>use self::sound::instrument</code> to <code>use super::sound::instrument</code>. Choosing whether
relative or absolute paths will result in fewer updates can be a guess if
you’re not sure how your module tree will change in the future, but your
authors tend to specify absolute paths starting with <code>crate</code> because code
defining and calling items is more likely to be moved around the module tree
independently of each other, rather than together as we saw in Listing 7-10.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#idiomatic-use-paths-for-functions-vs-other-items" id="idiomatic-use-paths-for-functions-vs-other-items"><h3>Idiomatic <code>use</code> Paths for Functions vs. Other Items</h3></a>
<p>In Listing 7-13, you may have wondered why we specified <code>use crate::sound::instrument</code> and then called <code>instrument::clarinet</code> in <code>main</code>,
rather than the code shown in Listing 7-16 that has the same behavior:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

use crate::sound::instrument::clarinet;

fn main() {
    clarinet();
    clarinet();
    clarinet();
}
</code></pre></pre>
<p><span class="caption">Listing 7-16: Bringing the <code>clarinet</code> function into
scope with <code>use</code>, which is unidiomatic</span></p>
<p>For functions, it’s considered idiomatic to specify the function’s parent
module with <code>use</code>, and then specify the parent module when calling the
function. Doing so rather than specifying the path to the function with <code>use</code>,
as Listing 7-16 does, makes it clear that the function isn’t locally defined,
while still minimizing repetition of the full path.</p>
<p>For structs, enums, and other items, specifying the full path to the item with
<code>use</code> is idiomatic. For example, Listing 7-17 shows the idiomatic way to bring
the standard library’s <code>HashMap</code> struct into scope.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Listing 7-17: Bringing <code>HashMap</code> into scope in an
idiomatic way</span></p>
<p>In contrast, the code in Listing 7-18 that brings the parent module of
<code>HashMap</code> into scope would not be considered idiomatic. There’s not a strong
reason for this idiom; this is the convention that has emerged and folks have
gotten used to reading and writing.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections;

fn main() {
    let mut map = collections::HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Listing 7-18: Bringing <code>HashMap</code> into scope in an
unidiomatic way</span></p>
<p>The exception to this idiom is if the <code>use</code> statements would bring two items
with the same name into scope, which isn’t allowed. Listing 7-19 shows how to
bring two <code>Result</code> types that have different parent modules into scope and
refer to them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
#     Ok(())
}

fn function2() -&gt; io::Result&lt;()&gt; {
#     Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-19: Bringing two types with the same name into
the same scope requires using their parent modules</span></p>
<p>If instead we specified <code>use std::fmt::Result</code> and <code>use std::io::Result</code>, we’d
have two <code>Result</code> types in the same scope and Rust wouldn’t know which one we
meant when we used <code>Result</code>. Try it and see what compiler error you get!</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#renaming-types-brought-into-scope-with-the-as-keyword" id="renaming-types-brought-into-scope-with-the-as-keyword"><h3>Renaming Types Brought Into Scope with the <code>as</code> Keyword</h3></a>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope: we can specify a new local name for the type by adding
<code>as</code> and a new name after the <code>use</code>. Listing 7-20 shows another way to write
the code from Listing 7-19 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
#     Ok(())
}
fn function2() -&gt; IoResult&lt;()&gt; {
#     Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-20: Renaming a type when it’s brought into
scope with the <code>as</code> keyword</span></p>
<p>In the second <code>use</code> statement, we chose the new name <code>IoResult</code> for the
<code>std::io::Result</code> type, which won’t conflict with the <code>Result</code> from <code>std::fmt</code>
that we’ve also brought into scope. This is also considered idiomatic; choosing
between the code in Listing 7-19 and Listing 7-20 is up to you.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#re-exporting-names-with-pub-use" id="re-exporting-names-with-pub-use"><h3>Re-exporting Names with <code>pub use</code></h3></a>
<p>When you bring a name into scope with the <code>use</code> keyword, the name being
available in the new scope is private. If you want to enable code calling your
code to be able to refer to the type as if it was defined in that scope just as
your code does, you can combine <code>pub</code> and <code>use</code>. This technique is called
<em>re-exporting</em> because you’re bringing an item into scope but also making that
item available for others to bring into their scope.</p>
<p>For example, Listing 7-21 shows the code from Listing 7-15 with the <code>use</code>
within the <code>performance_group</code> module changed to <code>pub use</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // Function body code goes here
        }
    }
}

mod performance_group {
    pub use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
    performance_group::instrument::clarinet();
}
</code></pre></pre>
<p><span class="caption">Listing 7-21: Making a name available for any code to use
from a new scope with <code>pub use</code></span></p>
<p>By using <code>pub use</code>, the <code>main</code> function can now call the <code>clarinet</code> function
through this new path with <code>performance_group::instrument::clarinet</code>. If we
hadn’t specified <code>pub use</code>, the <code>clarinet_trio</code> function can call
<code>instrument::clarinet</code> in its scope but <code>main</code> wouldn’t be allowed to take
advantage of this new path.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#using-external-packages" id="using-external-packages"><h3>Using External Packages</h3></a>
<p>In Chapter 2, we programmed a guessing game. That project used an external
package, <code>rand</code>, to get random numbers. To use <code>rand</code> in our project, we added
this line to <em>Cargo.toml</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the
<code>rand</code> package and its dependencies from <em>https://crates.io</em> and make its code
available to our project.</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a
<code>use</code> line starting with the name of the package, <code>rand</code>, and listing the items
we wanted to bring into scope. Recall that in the <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random
Number”</a><!-- ignore --> section in Chapter 2, we brought the <code>Rng</code> trait
into scope and called the <code>rand::thread_rng</code> function:</p>
<pre><code class="language-rust ignore">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}
</code></pre>
<p>There are many packages that members of the community have published on
<em>https://crates.io</em>, and pulling any of them into your package involves these
same steps: listing them in your package’s <em>Cargo.toml</em> and bringing items
defined in them into a scope in your package with <code>use</code>.</p>
<p>Note that the standard library (<code>std</code>) is also a crate that’s external to your
package. Because the standard library is shipped with the Rust language, you
don’t need to change <em>Cargo.toml</em> to include <code>std</code>, but you refer to it in
<code>use</code> to bring items the standard library defines into your package’s scope,
such as with <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;
#}</code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library
crate.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#nested-paths-for-cleaning-up-large-use-lists" id="nested-paths-for-cleaning-up-large-use-lists"><h3>Nested Paths for Cleaning Up Large <code>use</code> Lists</h3></a>
<p>When you use many items defined by the same package or in the same module,
listing each item on its own line can take up a lot of vertical space in your
files. For example, these two <code>use</code> statements we had in Listing 2-4 in the
Guessing Game both bring items from <code>std</code> into scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cmp::Ordering;
use std::io;
// ---snip---
#}</code></pre></pre>
<p>We can use nested paths to bring the same items into scope in one line instead
of two, by specifying the common part of the path, then two colons, then curly
brackets around a list of the parts of the paths that differ, as shown in
Listing 7-22.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::{cmp::Ordering, io};
// ---snip---
#}</code></pre></pre>
<p><span class="caption">Listing 7-22: Specifying a nested path to bring multiple
items with the same prefix into scope in one line instead of two</span></p>
<p>In programs bringing many items into scope from the same package or module,
using nested paths can reduce the number of separate <code>use</code> statements needed by
a lot!</p>
<p>We can also deduplicate paths where one path is completely shared with part of
another path. For example, Listing 7-23 shows two <code>use</code> statements: one that
brings <code>std::io</code> into scope, and one that brings <code>std::io::Write</code> into scope:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Write;
#}</code></pre></pre>
<p><span class="caption">Listing 7-23: Bringing two paths into scope in two <code>use</code>
statements where one is a sub-path of the other</span></p>
<p>The common part between these two paths is <code>std::io</code>, and that’s the complete
first path. To deduplicate these two paths into one <code>use</code> statement, we can use
<code>self</code> in the nested path as shown in Listing 7-24.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};
#}</code></pre></pre>
<p><span class="caption">Listing 7-24: Deduplicating the paths from Listing 7-23
into one <code>use</code> statement</span></p>
<p>This brings both <code>std::io</code> and <code>std::io::Write</code> into scope.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#bringing-all-public-definitions-into-scope-with-the-glob-operator" id="bringing-all-public-definitions-into-scope-with-the-glob-operator"><h3>Bringing All Public Definitions into Scope with the Glob Operator</h3></a>
<p>If you’d like to bring <em>all</em> public items defined in a path into scope, you can
specify that path followed by <code>*</code>, the glob operator:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::*;
#}</code></pre></pre>
<p>This <code>use</code> statements brings all public items defined in <code>std::collections</code>
into the current scope.</p>
<p>Be careful with using the glob operator! It makes it harder to tell what names
are in scope and where a name your program uses was defined.</p>
<p>The glob operator is often used when testing to bring everything under test
into the <code>tests</code> module; we’ll talk about that in the <a href="ch11-01-writing-tests.html#how-to-write-tests">“How to Write
Tests”</a><!-- ignore --> section of Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern; see <a href="../std/prelude/index.html#other-preludes">the standard
library documentation</a><!-- ignore -->
for more information on that pattern.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#separating-modules-into-different-files" id="separating-modules-into-different-files"><h3>Separating Modules into Different Files</h3></a>
<p>All of the examples in this chapter so far defined multiple modules in one
file. When modules get large, you may want to move their definitions to a
separate file to make the code easier to navigate.</p>
<p>For example, if we started from the code in Listing 7-8, we can move the
<code>sound</code> module to its own file <em>src/sound.rs</em> by changing the crate root file
(in this case, <em>src/main.rs</em>) to contain the code shown in Listing 7-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">mod sound;

fn main() {
    // Absolute path
    crate::sound::instrument::clarinet();

    // Relative path
    sound::instrument::clarinet();
}
</code></pre>
<p><span class="caption">Listing 7-25: Declaring the <code>sound</code> module whose body
will be in <em>src/sound.rs</em></span></p>
<p>And <em>src/sound.rs</em> gets the definitions from the body of the <code>sound</code> module,
shown in Listing 7-26.</p>
<p><span class="filename">Filename: src/sound.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod instrument {
    pub fn clarinet() {
        // Function body code goes here
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-26: Definitions inside the <code>sound</code> module in
<em>src/sound.rs</em></span></p>
<p>Using a semicolon after <code>mod sound</code> instead of a block tells Rust to load the
contents of the module from another file with the same name as the module.</p>
<p>To continue with our example and extract the <code>instrument</code> module to its own
file as well, we change <em>src/sound.rs</em> to contain only the declaration of the
<code>instrument</code> module:</p>
<p><span class="filename">Filename: src/sound.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod instrument;
#}</code></pre></pre>
<p>Then we create a <em>src/sound</em> directory and a file <em>src/sound/instrument.rs</em> to
contain the definitions made in the <code>instrument</code> module:</p>
<p><span class="filename">Filename: src/sound/instrument.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn clarinet() {
    // Function body code goes here
}
#}</code></pre></pre>
<p>The module tree remains the same and the function calls in <code>main</code> continue to
work without any modification, even though the definitions live in different
files. This lets you move modules to new files as they grow in size.</p>
<a class="header" href="ch07-02-modules-and-use-to-control-scope-and-privacy.html#summary" id="summary"><h2>Summary</h2></a>
<p>Rust provides ways to organize your packages into crates, your crates into
modules, and to refer to items defined in one module from another by specifying
absolute or relative paths. These paths can be brought into a scope with a
<code>use</code> statement so that you can use a shorter path for multiple uses of the
item in that scope. Modules define code that’s private by default, but you can
choose to make definitions public by adding the <code>pub</code> keyword.</p>
<p>Next, we’ll look at some collection data structures in the standard library
that you can use in your nice, neat code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch07-01-packages-and-crates-for-making-libraries-and-executables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-00-common-collections.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch07-01-packages-and-crates-for-making-libraries-and-executables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch08-00-common-collections.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

    </body>
</html>
