<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Associated Items - The Rust Reference</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/theme/reference.css">
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="notation.html"><strong aria-hidden="true">1.</strong> Notation</a></li><li><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> Lexical structure</a></li><li><ol class="section"><li><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> Input format</a></li><li><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> Keywords</a></li><li><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> Identifiers</a></li><li><a href="comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> Whitespace</a></li><li><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> Tokens</a></li><li><a href="paths.html"><strong aria-hidden="true">2.7.</strong> Paths</a></li></ol></li><li><a href="macros.html"><strong aria-hidden="true">3.</strong> Macros</a></li><li><ol class="section"><li><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> Macros By Example</a></li><li><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> Procedural Macros</a></li></ol></li><li><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crates and source files</a></li><li><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> Conditional compilation</a></li><li><a href="items-and-attributes.html"><strong aria-hidden="true">6.</strong> Items and attributes</a></li><li><ol class="section"><li><a href="items.html"><strong aria-hidden="true">6.1.</strong> Items</a></li><li><ol class="section"><li><a href="items/modules.html"><strong aria-hidden="true">6.1.1.</strong> Modules</a></li><li><a href="items/extern-crates.html"><strong aria-hidden="true">6.1.2.</strong> Extern crates</a></li><li><a href="items/use-declarations.html"><strong aria-hidden="true">6.1.3.</strong> Use declarations</a></li><li><a href="items/functions.html"><strong aria-hidden="true">6.1.4.</strong> Functions</a></li><li><a href="items/type-aliases.html"><strong aria-hidden="true">6.1.5.</strong> Type aliases</a></li><li><a href="items/structs.html"><strong aria-hidden="true">6.1.6.</strong> Structs</a></li><li><a href="items/enumerations.html"><strong aria-hidden="true">6.1.7.</strong> Enumerations</a></li><li><a href="items/unions.html"><strong aria-hidden="true">6.1.8.</strong> Unions</a></li><li><a href="items/constant-items.html"><strong aria-hidden="true">6.1.9.</strong> Constant items</a></li><li><a href="items/static-items.html"><strong aria-hidden="true">6.1.10.</strong> Static items</a></li><li><a href="items/traits.html"><strong aria-hidden="true">6.1.11.</strong> Traits</a></li><li><a href="items/implementations.html"><strong aria-hidden="true">6.1.12.</strong> Implementations</a></li><li><a href="items/external-blocks.html"><strong aria-hidden="true">6.1.13.</strong> External blocks</a></li></ol></li><li><a href="items/generics.html"><strong aria-hidden="true">6.2.</strong> Type and lifetime parameters</a></li><li><a href="items/associated-items.html" class="active"><strong aria-hidden="true">6.3.</strong> Associated Items</a></li><li><a href="visibility-and-privacy.html"><strong aria-hidden="true">6.4.</strong> Visibility and Privacy</a></li><li><a href="attributes.html"><strong aria-hidden="true">6.5.</strong> Attributes</a></li></ol></li><li><a href="statements-and-expressions.html"><strong aria-hidden="true">7.</strong> Statements and expressions</a></li><li><ol class="section"><li><a href="statements.html"><strong aria-hidden="true">7.1.</strong> Statements</a></li><li><a href="expressions.html"><strong aria-hidden="true">7.2.</strong> Expressions</a></li><li><ol class="section"><li><a href="expressions/literal-expr.html"><strong aria-hidden="true">7.2.1.</strong> Literal expressions</a></li><li><a href="expressions/path-expr.html"><strong aria-hidden="true">7.2.2.</strong> Path expressions</a></li><li><a href="expressions/block-expr.html"><strong aria-hidden="true">7.2.3.</strong> Block expressions</a></li><li><a href="expressions/operator-expr.html"><strong aria-hidden="true">7.2.4.</strong> Operator expressions</a></li><li><a href="expressions/grouped-expr.html"><strong aria-hidden="true">7.2.5.</strong> Grouped expressions</a></li><li><a href="expressions/array-expr.html"><strong aria-hidden="true">7.2.6.</strong> Array and index expressions</a></li><li><a href="expressions/tuple-expr.html"><strong aria-hidden="true">7.2.7.</strong> Tuple and index expressions</a></li><li><a href="expressions/struct-expr.html"><strong aria-hidden="true">7.2.8.</strong> Struct expressions</a></li><li><a href="expressions/enum-variant-expr.html"><strong aria-hidden="true">7.2.9.</strong> Enum variant expressions</a></li><li><a href="expressions/call-expr.html"><strong aria-hidden="true">7.2.10.</strong> Call expressions</a></li><li><a href="expressions/method-call-expr.html"><strong aria-hidden="true">7.2.11.</strong> Method call expressions</a></li><li><a href="expressions/field-expr.html"><strong aria-hidden="true">7.2.12.</strong> Field access expressions</a></li><li><a href="expressions/closure-expr.html"><strong aria-hidden="true">7.2.13.</strong> Closure expressions</a></li><li><a href="expressions/loop-expr.html"><strong aria-hidden="true">7.2.14.</strong> Loop expressions</a></li><li><a href="expressions/range-expr.html"><strong aria-hidden="true">7.2.15.</strong> Range expressions</a></li><li><a href="expressions/if-expr.html"><strong aria-hidden="true">7.2.16.</strong> If and if let expressions</a></li><li><a href="expressions/match-expr.html"><strong aria-hidden="true">7.2.17.</strong> Match expressions</a></li><li><a href="expressions/return-expr.html"><strong aria-hidden="true">7.2.18.</strong> Return expressions</a></li></ol></li></ol></li><li><a href="patterns.html"><strong aria-hidden="true">8.</strong> Patterns</a></li><li><a href="type-system.html"><strong aria-hidden="true">9.</strong> Type system</a></li><li><ol class="section"><li><a href="types.html"><strong aria-hidden="true">9.1.</strong> Types</a></li><li><ol class="section"><li><a href="types/boolean.html"><strong aria-hidden="true">9.1.1.</strong> Boolean type</a></li><li><a href="types/numeric.html"><strong aria-hidden="true">9.1.2.</strong> Numeric types</a></li><li><a href="types/textual.html"><strong aria-hidden="true">9.1.3.</strong> Textual types</a></li><li><a href="types/never.html"><strong aria-hidden="true">9.1.4.</strong> Never type</a></li><li><a href="types/tuple.html"><strong aria-hidden="true">9.1.5.</strong> Tuple types</a></li><li><a href="types/array.html"><strong aria-hidden="true">9.1.6.</strong> Array types</a></li><li><a href="types/slice.html"><strong aria-hidden="true">9.1.7.</strong> Slice types</a></li><li><a href="types/struct.html"><strong aria-hidden="true">9.1.8.</strong> Struct types</a></li><li><a href="types/enum.html"><strong aria-hidden="true">9.1.9.</strong> Enumerated types</a></li><li><a href="types/union.html"><strong aria-hidden="true">9.1.10.</strong> Union types</a></li><li><a href="types/function-item.html"><strong aria-hidden="true">9.1.11.</strong> Function item types</a></li><li><a href="types/closure.html"><strong aria-hidden="true">9.1.12.</strong> Closure types</a></li><li><a href="types/pointer.html"><strong aria-hidden="true">9.1.13.</strong> Pointer types</a></li><li><a href="types/function-pointer.html"><strong aria-hidden="true">9.1.14.</strong> Function pointer types</a></li><li><a href="types/trait-object.html"><strong aria-hidden="true">9.1.15.</strong> Trait object types</a></li><li><a href="types/impl-trait.html"><strong aria-hidden="true">9.1.16.</strong> Impl trait type</a></li><li><a href="types/parameters.html"><strong aria-hidden="true">9.1.17.</strong> Type parameters</a></li><li><a href="types/inferred.html"><strong aria-hidden="true">9.1.18.</strong> Inferred type</a></li></ol></li><li><a href="dynamically-sized-types.html"><strong aria-hidden="true">9.2.</strong> Dynamically Sized Types</a></li><li><a href="type-layout.html"><strong aria-hidden="true">9.3.</strong> Type layout</a></li><li><a href="interior-mutability.html"><strong aria-hidden="true">9.4.</strong> Interior mutability</a></li><li><a href="subtyping.html"><strong aria-hidden="true">9.5.</strong> Subtyping and Variance</a></li><li><a href="trait-bounds.html"><strong aria-hidden="true">9.6.</strong> Trait and lifetime bounds</a></li><li><a href="type-coercions.html"><strong aria-hidden="true">9.7.</strong> Type coercions</a></li><li><a href="destructors.html"><strong aria-hidden="true">9.8.</strong> Destructors</a></li><li><a href="lifetime-elision.html"><strong aria-hidden="true">9.9.</strong> Lifetime elision</a></li></ol></li><li><a href="special-types-and-traits.html"><strong aria-hidden="true">10.</strong> Special types and traits</a></li><li><a href="memory-model.html"><strong aria-hidden="true">11.</strong> Memory model</a></li><li><ol class="section"><li><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">11.1.</strong> Memory allocation and lifetime</a></li><li><a href="memory-ownership.html"><strong aria-hidden="true">11.2.</strong> Memory ownership</a></li><li><a href="variables.html"><strong aria-hidden="true">11.3.</strong> Variables</a></li></ol></li><li><a href="linkage.html"><strong aria-hidden="true">12.</strong> Linkage</a></li><li><a href="unsafety.html"><strong aria-hidden="true">13.</strong> Unsafety</a></li><li><ol class="section"><li><a href="unsafe-functions.html"><strong aria-hidden="true">13.1.</strong> Unsafe functions</a></li><li><a href="unsafe-blocks.html"><strong aria-hidden="true">13.2.</strong> Unsafe blocks</a></li><li><a href="behavior-considered-undefined.html"><strong aria-hidden="true">13.3.</strong> Behavior considered undefined</a></li><li><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">13.4.</strong> Behavior not considered unsafe</a></li></ol></li><li><a href="const_eval.html"><strong aria-hidden="true">14.</strong> Constant Evaluation</a></li><li class="affix"><a href="influences.html">Appendix: Influences</a></li><li class="affix"><a href="undocumented.html">Appendix: As-yet-undocumented Features</a></li><li class="affix"><a href="glossary.html">Appendix: Glossary</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <header><p class="warning">
    For now, this reference is a best-effort document. We strive for validity
    and completeness, but are not yet there. In the future, the docs and lang
    teams will work together to figure out how best to do this. Until then, this
    is a best-effort attempt. If you find something wrong or missing, file an
    <a href="https://github.com/rust-lang-nursery/reference/issues">issue</a> or
    send in a pull request.
</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Reference</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="items/associated-items.html#associated-items" id="associated-items"><h1>Associated Items</h1></a>
<p><em>Associated Items</em> are the items declared in <a href="items/traits.html">traits</a> or defined in
<a href="items/implementations.html">implementations</a>. They are called this because they are defined on an associate
type — the type in the implementation. They are a subset of the kinds of
items you can declare in a module. Specifically, there are <a href="items/associated-items.html#associated-functions-and-methods">associated
functions</a> (including methods), <a href="items/associated-items.html#associated-types">associated types</a>, and <a href="items/associated-items.html#associated-constants">associated constants</a>.</p>
<p>Associated items are useful when the associated item logically is related to the
associating item. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically
related to Options, so should be associated.</p>
<p>Every associated item kind comes in two varieties: definitions that contain the
actual implementation and declarations that declare signatures for
definitions.</p>
<p>It is the declarations that make up the contract of traits and what it available
on generic types.</p>
<a class="header" href="items/associated-items.html#associated-functions-and-methods" id="associated-functions-and-methods"><h2>Associated functions and methods</h2></a>
<p><em>Associated functions</em> are <a href="items/functions.html">functions</a> associated with a type.</p>
<p>An <em>associated function declaration</em> declares a signature for an associated
function definition. It is written as a function item, except the
function body is replaced with a <code>;</code>.</p>
<p>The identifier is the name of the function. The generics, parameter list,
return type, and where clause of the associated function must be the same as the
associated function declarations's.</p>
<p>An <em>associated function definition</em> defines a function associated with another
type. It is written the same as a <a href="types/function-item.html">function item</a>.</p>
<p>An example of a common associated function is a <code>new</code> function that returns
a value of the type the associated function is associated with.</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}
</code></pre></pre>
<p>When the associated function is declared on a trait, the function can also be
called with a <a href="paths.html">path</a> that is a path to the trait appended by the name of the
trait. When this happens, it is substituted for <code>&lt;_ as Trait&gt;::function_name</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// These 4 are all equivalent in this case.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
#}</code></pre></pre>
<a class="header" href="items/associated-items.html#methods" id="methods"><h3>Methods</h3></a>
<blockquote>
<p><em>Method</em> :<br />
   <a href="items/functions.html"><em>FunctionQualifiers</em></a> <code>fn</code> <a href="identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
      <code>(</code> <em>SelfParam</em> (<code>,</code> <a href="items/functions.html"><em>FunctionParam</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> <code>)</code><br />
      <a href="items/functions.html"><em>FunctionReturnType</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup><br />
      <a href="expressions/block-expr.html"><em>BlockExpression</em></a></p>
<p><em>SelfParam</em> :<br />
      (<code>&amp;</code> | <code>&amp;</code> <a href="trait-bounds.html"><em>Lifetime</em></a>)<sup>?</sup> <code>mut</code><sup>?</sup> <code>self</code><br />
   | <code>mut</code><sup>?</sup> <code>self</code> (<code>:</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>?</sup></p>
</blockquote>
<p>Associated functions whose first parameter is named <code>self</code> are called <em>methods</em>
and may be invoked using the <a href="expressions/method-call-expr.html">method call operator</a>, for example, <code>x.foo()</code>, as
well as the usual function call notation.</p>
<p>If the type of the <code>self</code> parameter is specified, it is limited to the type
being implemented (or <code>Self</code>), or a reference or mutable reference to the
type, or a boxed value of the type being implemented (such as <code>Box&lt;Self&gt;</code>).
Shorthand syntax can be used without specifying a type, which have the
following equivalents:</p>
<table><thead><tr><th>Shorthand             </th><th> Equivalent</th></tr></thead><tbody>
<tr><td><code>self</code>                </td><td> <code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code>     </td><td> <code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code> </td><td> <code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
<blockquote>
<p>Note: Lifetimes can be and usually are elided with this shorthand.</p>
</blockquote>
<p>Consider the following trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# type Surface = i32;
# type BoundingBox = i32;
trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
#}</code></pre></pre>
<p>This defines a trait with two methods. All values that have <a href="items/implementations.html">implementations</a>
of this trait while the trait is in scope can have their <code>draw</code> and
<code>bounding_box</code> methods called.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# type Surface = i32;
# type BoundingBox = i32;
# trait Shape {
#     fn draw(&amp;self, surface: Surface);
#     fn bounding_box(&amp;self) -&gt; BoundingBox;
# }
#
struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
#   fn draw(&amp;self, _: Surface) {}
#   fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
}

# impl Circle {
#     fn new() -&gt; Circle { Circle{} }
# }
#
let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
#}</code></pre></pre>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, it is possible to declare trait
methods with anonymous parameters (e.g. <code>fn foo(u8)</code>). This is deprecated and
an error as of the 2018 edition. All parameters must have an argument name.</p>
</blockquote>
<a class="header" href="items/associated-items.html#associated-types" id="associated-types"><h2>Associated Types</h2></a>
<p><em>Associated types</em> are <a href="items/type-aliases.html">type aliases</a> associated with another type. Associated
types cannot be defined in <a href="items/implementations.html#inherent-implementations">inherent implementations</a> nor can they be given a
default implementation in traits.</p>
<p>An <em>associated type declaration</em> declares a signature for associated type
definitions. It is written as <code>type</code>, then an <a href="identifiers.html">identifier</a>, and
finally an optional list of trait bounds.</p>
<p>The identifier is the name of the declared type alias. The optional trait bounds
must be fulfilled by the implementations of the type alias.</p>
<p>An <em>associated type definition</em> defines a type alias on another type. It is
written as <code>type</code>, then an <a href="identifiers.html">identifier</a>, then an <code>=</code>, and finally a <a href="types.html#type-expressions">type</a>.</p>
<p>If a type <code>Item</code> has an associated type <code>Assoc</code> from a trait <code>Trait</code>, then
<code>&lt;Item as Trait&gt;::Assoc</code> is a type that is an alias of the type specified in the
associated type definition. Furthermore, if <code>Item</code> is a type parameter, then
<code>Item::Assoc</code> can be used in type parameters.</p>
<pre><pre class="playpen"><code class="language-rust">trait AssociatedType {
    // Associated type declaration
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // Associated type definition
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // Usage of the associated type to refer to OtherStruct as &lt;Struct as AssociatedType&gt;::Assoc
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}
</code></pre></pre>
<a class="header" href="items/associated-items.html#associated-types-container-example" id="associated-types-container-example"><h3>Associated Types Container Example</h3></a>
<p>Consider the following example of a <code>Container</code> trait. Notice that the type is
available for use in the method signatures:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
#}</code></pre></pre>
<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here's an
implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Container {
#     type E;
#     fn empty() -&gt; Self;
#     fn insert(&amp;mut self, elem: Self::E);
# }
impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
#}</code></pre></pre>
<a class="header" href="items/associated-items.html#associated-constants" id="associated-constants"><h2>Associated Constants</h2></a>
<p><em>Associated constants</em> are <a href="items/constant-items.html">constants</a> associated with a type.</p>
<p>An <em>associated constant declaration</em> declares a signature for associated
constant definitions. It is written as <code>const</code>, then an identifier,
then <code>:</code>, then a type, finished by a <code>;</code>.</p>
<p>The identifier is the name of the constant used in the path. The type is the
type that the definition has to implement.</p>
<p>An <em>associated constant definition</em> defines a constant associated with a
type. It is written the same as a <a href="items/constant-items.html">constant item</a>.</p>
<a class="header" href="items/associated-items.html#associated-constants-examples" id="associated-constants-examples"><h3>Associated Constants Examples</h3></a>
<p>A basic example:</p>
<pre><pre class="playpen"><code class="language-rust">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}
</code></pre></pre>
<p>Using default values:</p>
<pre><pre class="playpen"><code class="language-rust">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="items/generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="visibility-and-privacy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="items/generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="visibility-and-privacy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
